---
import Button from "@/components/ui/Button.astro";
import { ArrowRight, Search } from "@lucide/astro";
import Input from "./Input.astro";
import { applyStyles } from "@/utils/apply-styles";

export interface Props {
  placeholder?: string;
  buttonText?: string;
  class?: string;
  showDescription?: boolean;
}

const {
  placeholder = "0x1234567890abcdef... or vitalik.eth",
  buttonText = "Analyze Security",
  class: className = "",
  showDescription = true,
} = Astro.props;
---

<div class={`address-search-form ${className}`}>
  <form
    id="address-form"
    method="post"
    class={applyStyles(
      "mt-10 flex flex-col items-center justify-center gap-5 sm:flex-row sm:items-stretch",
      className,
    )}
  >
    <Input
      variant="outline"
      aria-label="Ethereum Address"
      class="md:!w-[567px]"
      id="security-checker-input"
      type="text"
      name="address"
      placeholder={"Enter wallet address or ENS name"}
      required
    />

    <Button
      id="security-checker-button"
      variant="secondary"
      type="submit"
      class="w-[168px]"
    >
      <span class="flex items-center gap-4">
        Analyze
        <ArrowRight />
      </span>
    </Button>
  </form>

  <div
    id="error-message"
    class="mt-4 hidden md:mx-auto md:max-w-[calc(567px+168px)]"
  >
    <div class="rounded-lg border border-red-300 bg-red-100 p-4">
      <p class="font-body text-red-700" id="error-text"></p>
    </div>
  </div>

  <div
    id="loading-message"
    class="mt-4 hidden md:mx-auto md:max-w-[calc(567px+168px)]"
  >
    <div class="rounded-lg border border-blue-300 bg-blue-100 p-4">
      <p class="font-body flex items-center gap-2 text-blue-700">
        <span
          class="h-4 w-4 animate-spin rounded-full border-2 border-blue-600 border-t-transparent"
        ></span>
        Analyzing address...
      </p>
    </div>
  </div>
</div>

<script>
  // Validation functions
  function isValidEthereumAddress(address: string): boolean {
    const ethAddressRegex = /^0x[a-fA-F0-9]{40}$/;
    return ethAddressRegex.test(address);
  }

  function isValidENSName(input: string): boolean {
    if (!input || typeof input !== "string") return false;
    const trimmed = input.trim().toLowerCase();
    if (!trimmed.endsWith(".eth") || trimmed.startsWith("0x")) return false;
    const ensPattern = /^[a-zA-Z0-9-]+\.eth$/;
    return ensPattern.test(trimmed);
  }

  function validateAddressOrENS(input: string): { isValid: boolean; type: "address" | "ens" | "invalid" } {
    if (!input || typeof input !== "string") {
      return { isValid: false, type: "invalid" };
    }

    const cleanInput = input.trim();

    if (isValidEthereumAddress(cleanInput)) {
      return { isValid: true, type: "address" };
    }

    if (isValidENSName(cleanInput)) {
      return { isValid: true, type: "ens" };
    }

    return { isValid: false, type: "invalid" };
  }

  function initializeAddressForm() {
    const form = document.getElementById("address-form") as HTMLFormElement;
    const errorMessage = document.getElementById("error-message") as HTMLElement;
    const errorText = document.getElementById("error-text") as HTMLElement;
    const loadingMessage = document.getElementById("loading-message") as HTMLElement;
    const analyzeButton = document.getElementById("analyze-button") as HTMLButtonElement;

    if (!form) return;

    form.addEventListener("submit", async (e) => {
      e.preventDefault();

      const formData = new FormData(form);
      const input = (formData.get("address") as string)?.trim();

      // Hide previous messages
      errorMessage?.classList.add("hidden");
      loadingMessage?.classList.remove("hidden");
      if (analyzeButton) analyzeButton.disabled = true;

      try {
        if (!input) {
          throw new Error("Please enter an Ethereum address or ENS name");
        }

        const validation = validateAddressOrENS(input);

        if (!validation.isValid) {
          throw new Error(
            "Please enter a valid Ethereum address (0x...) or ENS .eth name (example.eth)"
          );
        }

        // Navigate to the security report page with the input (API will handle resolution)
        window.location.href = `/security-report/${encodeURIComponent(input)}`;
      } catch (error) {
        // Show error message
        loadingMessage?.classList.add("hidden");
        if (errorText) {
          errorText.textContent =
            error instanceof Error
              ? error.message
              : "An error occurred while processing your request";
        }
        errorMessage?.classList.remove("hidden");
        if (analyzeButton) analyzeButton.disabled = false;
      }
    });
  }

  // Initialize when DOM is loaded
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeAddressForm);
  } else {
    initializeAddressForm();
  }
</script>
